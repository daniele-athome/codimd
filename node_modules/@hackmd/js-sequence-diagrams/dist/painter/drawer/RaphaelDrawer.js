import { ALIGN_CENTER, ALIGN_HORIZONTAL_CENTER, ALIGN_LEFT, ALIGN_VERTICAL_CENTER, BaseDrawer, } from './BaseDrawer';
import { ArrowType, LineType } from '../../parser/enum';
import { assert } from '../../utils';
const RECT = {
    fill: '#fff',
    stroke: '#000000',
    'stroke-width': 2,
};
const LINE = {
    fill: 'none',
    stroke: '#000000',
    'stroke-width': 2,
};
Raphael.fn.line = function (x1, y1, x2, y2) {
    assert([x1, x2, y1, y2].every(n => Number.isFinite(n)), 'x1,x2,y1,y2 must be numeric');
    return this.path('M{0},{1} L{2},{3}', x1, y1, x2, y2);
};
export class RaphaelDrawer extends BaseDrawer {
    constructor(diagram, options) {
        super(diagram);
        this.arrowTypes = {
            [ArrowType.Filled]: 'black',
            [ArrowType.Open]: 'open',
        };
        this.lineTypes = {
            [LineType.Solid]: '',
            [LineType.Dotted]: '-',
        };
        this.font = {
            'font-family': options['font-family'] || 'Andale Mono, monospace',
            'font-size': options['font-size'] || 16,
        };
    }
    static cleanText(text) {
        return text.split('\n').map(x => x.trim()).join('\n');
    }
    draw(container) {
        super.draw(container);
        this.paper.setFinish();
    }
    setupCanvas(container) {
        this.paper = Raphael(container, 300, 200);
        this.paper.setStart();
    }
    resize(width, height) {
        this.paper.setSize(width, height);
    }
    textBBox(rawText, font = this.font) {
        const text = RaphaelDrawer.cleanText(rawText);
        let p;
        if (font.obj_) {
            p = this.paper.print(0, 0, text, font.obj_, font['font-size']);
        }
        else {
            p = this.paper.text(0, 0, text);
            p.attr(font);
        }
        const bb = p.getBBox();
        p.remove();
        return bb;
    }
    drawRect(x, y, w, h) {
        this.paper.rect(x, y, w, h).attr(RECT);
    }
    drawText(x, y, rawText, font = {}, align = ALIGN_LEFT) {
        const text = RaphaelDrawer.cleanText(rawText);
        const bb = this.textBBox(text, font);
        let x1 = x;
        let y1 = y;
        if (align === ALIGN_CENTER || align === ALIGN_HORIZONTAL_CENTER) {
            x1 = x1 - bb.width / 2;
        }
        if (align === ALIGN_CENTER || align === ALIGN_VERTICAL_CENTER) {
            y1 = y1 - bb.height / 2;
        }
        let t;
        if (font.obj_) {
            t = this.paper.print(x1 - bb.x, y1 - bb.y, text, font.obj_, font['font-size']);
        }
        else {
            t = this.paper.text(x1 - bb.x - bb.width / 2, y1 - bb.y, text);
            t.attr(font);
            t.attr({
                'text-anchor': 'start',
            });
        }
        return t;
    }
    drawLine(x1, y1, x2, y2, lineType, arrowHead) {
        const line = this.paper.line(x1, y1, x2, y2).attr(LINE);
        if (arrowHead !== undefined) {
            line.attr('arrow-end', `${this.arrowTypes[arrowHead]}-wide-long`);
        }
        if (lineType !== undefined) {
            line.attr('stroke-dasharray', this.lineTypes[lineType]);
        }
        return line;
    }
}
