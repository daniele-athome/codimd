"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var constants_1 = require("./constants");
var response_metadata_extractor_1 = require("@aws-sdk/response-metadata-extractor");
var util_error_constructor_1 = require("@aws-sdk/util-error-constructor");
exports.queryErrorUnmarshaller = function (operation, input, errorBodyParser) {
    var e_1, _a;
    var body = input.body;
    var errors = operation.errors, operationName = operation.name;
    var _b = parseErrorCommonProperties(errorBodyParser, body), errorName = _b.name, errorMessage = _b.message, requestId = _b.requestId;
    var $metadata = tslib_1.__assign({}, response_metadata_extractor_1.extractMetadata(input), { requestId: requestId });
    if (!errorName) {
        return util_error_constructor_1.initServiceException(new Error(), {
            $metadata: $metadata,
            operationName: operationName
        });
    }
    try {
        //parse error properties from API other than name and message
        for (var errors_1 = tslib_1.__values(errors), errors_1_1 = errors_1.next(); !errors_1_1.done; errors_1_1 = errors_1.next()) {
            var errorShape = errors_1_1.value;
            var errorStructure = errorShape.shape;
            if (errorStructure.exceptionCode === errorName ||
                (!errorStructure.exceptionCode &&
                    errorStructure.exceptionType === errorName)) {
                var rawException = parseErrorOwnProperties(errorShape, body, errorBodyParser);
                return util_error_constructor_1.initServiceException(new Error(), {
                    $metadata: tslib_1.__assign({}, response_metadata_extractor_1.extractMetadata(input), { requestId: requestId }),
                    name: errorName,
                    message: errorMessage,
                    rawException: rawException,
                    operationName: operationName
                });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (errors_1_1 && !errors_1_1.done && (_a = errors_1.return)) _a.call(errors_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    //parsable exception but not documented in API
    return util_error_constructor_1.initServiceException(new Error(), {
        $metadata: tslib_1.__assign({}, response_metadata_extractor_1.extractMetadata(input), { requestId: requestId }),
        name: errorName,
        message: errorMessage,
        operationName: operationName
    });
};
function parseErrorOwnProperties(errorShape, body, errorBodyParser) {
    if (!errorShape.shape.members) {
        return {};
    }
    var wrappedErrorShape = {
        shape: {
            type: "structure",
            required: [],
            members: {
                Error: errorShape
            }
        }
    };
    var rawException = errorBodyParser.parse(wrappedErrorShape, body);
    return rawException.Error;
}
function parseErrorCommonProperties(errorBodyParser, body) {
    var parsedErrorResponse = errorBodyParser.parse(constants_1.ERR_RESP_SHAPE, body);
    var requestId = parsedErrorResponse.$metadata
        ? parsedErrorResponse.$metadata.requestId
        : undefined;
    if (parsedErrorResponse.Error) {
        var _a = parsedErrorResponse.Error, _b = _a.Code, errorName = _b === void 0 ? undefined : _b, _c = _a.Message, errorMessage = _c === void 0 ? undefined : _c, requestId_1 = parsedErrorResponse.$metadata.requestId;
        return { name: errorName, message: errorMessage, requestId: requestId_1 };
    }
    return { name: undefined, message: undefined, requestId: requestId };
}
//# sourceMappingURL=index.js.map