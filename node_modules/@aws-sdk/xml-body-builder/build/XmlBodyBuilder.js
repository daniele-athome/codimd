"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var is_iterable_1 = require("@aws-sdk/is-iterable");
var protocol_timestamp_1 = require("@aws-sdk/protocol-timestamp");
var xml_builder_1 = require("@aws-sdk/xml-builder");
var XML_NAMESPACE_PREFIX = "xmlns";
var XmlBodyBuilder = /** @class */ (function () {
    function XmlBodyBuilder(base64Encoder, utf8Decoder) {
        this.base64Encoder = base64Encoder;
        this.utf8Decoder = utf8Decoder;
    }
    XmlBodyBuilder.prototype.build = function (_a) {
        var operation = _a.operation, _b = _a.member, member = _b === void 0 ? operation.input : _b, hasPayload = _a.hasPayload, input = _a.input, memberName = _a.memberName;
        var xmlNamespace;
        var shape = member.shape;
        if (member.xmlNamespace && member.xmlNamespace.uri) {
            xmlNamespace = member.xmlNamespace;
        }
        if (hasPayload && (input === void 0 || input === null)) {
            return "";
        }
        var allowEmpty = hasPayload !== true;
        var rootName = memberName || operation.name + "Request";
        return this.toXml(member, input, rootName, allowEmpty, xmlNamespace);
    };
    XmlBodyBuilder.prototype.toXml = function (member, input, rootName, allowEmpty, xmlNamespace) {
        var rootNode = new xml_builder_1.XmlNode(rootName);
        // apply namespace if necessary
        if (xmlNamespace && xmlNamespace.uri) {
            var prefix = xmlNamespace.prefix
                ? XML_NAMESPACE_PREFIX + ":" + xmlNamespace.prefix
                : XML_NAMESPACE_PREFIX;
            rootNode.addAttribute(prefix, xmlNamespace.uri);
        }
        this.serialize(rootNode, member, input);
        return rootNode.children.length || !allowEmpty ? rootNode.toString() : "";
    };
    XmlBodyBuilder.prototype.serialize = function (node, member, input) {
        switch (member.shape.type) {
            case "structure":
                return this.serializeStructure(node, member, input);
            case "map":
                return this.serializeMap(node, member, input);
            case "list":
                return this.serializeList(node, member, input);
            case "float":
                return this.serializeFloat(node, member, input);
            case "integer":
                return this.serializeInteger(node, member, input);
            case "string":
                return this.serializeString(node, member, input);
            case "timestamp":
                return this.serializeTimestamp(node, member, input);
            case "blob":
                return this.serializeBlob(node, member, input);
            default:
                return this.serializeScalar(node, member, input);
        }
    };
    XmlBodyBuilder.prototype.serializeStructure = function (node, member, input) {
        var e_1, _a;
        // sanity check. May be undefined if input has a payload member.
        if (input === void 0 || input === null) {
            return;
        }
        var shape = member.shape;
        try {
            for (var _b = tslib_1.__values(Object.keys(shape.members)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var memberName = _c.value;
                var inputValue = input[memberName];
                if (typeof inputValue === "undefined" || inputValue === null) {
                    continue;
                }
                var structureMember = shape.members[memberName];
                var _d = structureMember.flattened, flattened = _d === void 0 ? structureMember.shape.flattened : _d, location = structureMember.location, _e = structureMember.locationName, locationName = _e === void 0 ? memberName : _e, xmlAttribute = structureMember.xmlAttribute, xmlNamespace = structureMember.xmlNamespace;
                // this field belongs somewhere other than the body
                if (location) {
                    continue;
                }
                var memberType = structureMember.shape.type;
                if (xmlAttribute) {
                    node.addAttribute(locationName, inputValue);
                }
                else if (flattened) {
                    this.serializeStructureMember(node, structureMember, inputValue, locationName);
                }
                else {
                    // create a new element
                    var childNode = new xml_builder_1.XmlNode(locationName);
                    if (xmlNamespace && xmlNamespace.uri) {
                        var prefix = xmlNamespace.prefix
                            ? XML_NAMESPACE_PREFIX + ":" + xmlNamespace.prefix
                            : XML_NAMESPACE_PREFIX;
                        childNode.addAttribute(prefix, xmlNamespace.uri);
                    }
                    this.serializeStructureMember(childNode, structureMember, inputValue, memberName);
                    node.addChildNode(childNode);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    XmlBodyBuilder.prototype.serializeStructureMember = function (node, structureMember, inputValue, memberName) {
        var memberType = structureMember.shape.type;
        if (memberType === "list") {
            this.serializeList(node, structureMember, inputValue, memberName);
        }
        else if (memberType === "map") {
            this.serializeMap(node, structureMember, inputValue, memberName);
        }
        else {
            this.serialize(node, structureMember, inputValue);
        }
    };
    XmlBodyBuilder.prototype.serializeMap = function (node, member, input, memberName) {
        var e_2, _a, e_3, _b;
        var name = member.locationName || memberName;
        var shape = member.shape;
        var _c = shape.flattened, flattened = _c === void 0 ? member.flattened : _c, _d = shape.key.locationName, xmlKey = _d === void 0 ? "key" : _d, _e = shape.value.locationName, xmlValue = _e === void 0 ? "value" : _e;
        if (!flattened) {
            name = "entry";
        }
        if (is_iterable_1.isIterable(input)) {
            try {
                for (var input_1 = tslib_1.__values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
                    var _f = tslib_1.__read(input_1_1.value, 2), inputKey = _f[0], inputValue = _f[1];
                    var childNode = this.formatMap(shape, name, xmlKey, xmlValue, inputKey, inputValue);
                    node.addChildNode(childNode);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        else if (typeof input === "object" && input !== null) {
            try {
                for (var _g = tslib_1.__values(Object.keys(input)), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var inputKey = _h.value;
                    var childNode = this.formatMap(shape, name, xmlKey, xmlValue, inputKey, input[inputKey]);
                    node.addChildNode(childNode);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else {
            throw new Error("Unable to serialize value that is neither a [key, value]" +
                " iterable nor an object as a map");
        }
    };
    XmlBodyBuilder.prototype.formatMap = function (shape, name, xmlKey, xmlValue, inputKey, inputValue) {
        var keyNode = new xml_builder_1.XmlNode(xmlKey);
        var valueNode = new xml_builder_1.XmlNode(xmlValue);
        this.serialize(keyNode, shape.key, inputKey);
        this.serialize(valueNode, shape.value, inputValue);
        return new xml_builder_1.XmlNode(name, [keyNode, valueNode]);
    };
    XmlBodyBuilder.prototype.serializeList = function (node, member, input, memberName) {
        var e_4, _a;
        var shape = member.shape;
        var flattened = shape.flattened;
        var name = shape.member.locationName;
        if (!name) {
            name = flattened ? memberName : "member";
        }
        if (Array.isArray(input) || is_iterable_1.isIterable(input)) {
            try {
                for (var input_2 = tslib_1.__values(input), input_2_1 = input_2.next(); !input_2_1.done; input_2_1 = input_2.next()) {
                    var value = input_2_1.value;
                    var childNode = new xml_builder_1.XmlNode(name);
                    this.serialize(childNode, shape.member, value);
                    node.addChildNode(childNode);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (input_2_1 && !input_2_1.done && (_a = input_2.return)) _a.call(input_2);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        else {
            throw new Error("Unable to serialize value that is neither an array nor an" +
                " iterable as a list");
        }
    };
    XmlBodyBuilder.prototype.serializeScalar = function (node, member, input) {
        node.addChildNode(new xml_builder_1.XmlText(input));
    };
    XmlBodyBuilder.prototype.serializeBlob = function (node, member, input) {
        if (typeof input === "string") {
            input = this.utf8Decoder(input);
        }
        node.addChildNode(new xml_builder_1.XmlText(this.base64Encoder(input)));
    };
    XmlBodyBuilder.prototype.serializeFloat = function (node, member, input) {
        node.addChildNode(new xml_builder_1.XmlText(String(parseFloat(input))));
    };
    XmlBodyBuilder.prototype.serializeInteger = function (node, member, input) {
        node.addChildNode(new xml_builder_1.XmlText(String(parseInt(input, 10))));
    };
    XmlBodyBuilder.prototype.serializeString = function (node, member, input) {
        node.addChildNode(new xml_builder_1.XmlText(input));
    };
    XmlBodyBuilder.prototype.serializeTimestamp = function (node, member, input) {
        var timestampFormat = member.timestampFormat
            ? member.timestampFormat
            : member.shape.timestampFormat;
        switch (timestampFormat) {
            case "unixTimestamp":
                node.addChildNode(new xml_builder_1.XmlText(String(protocol_timestamp_1.epoch(input))));
                break;
            case "rfc822":
                node.addChildNode(new xml_builder_1.XmlText(protocol_timestamp_1.rfc822(input)));
                break;
            default:
                node.addChildNode(new xml_builder_1.XmlText(protocol_timestamp_1.iso8601(input)));
                break;
        }
    };
    return XmlBodyBuilder;
}());
exports.XmlBodyBuilder = XmlBodyBuilder;
//# sourceMappingURL=XmlBodyBuilder.js.map