/*! markmap-lib v0.4.2 | MIT License */
'use strict';

var remarkable = require('remarkable');

const md = new remarkable.Remarkable();
md.block.ruler.enable(['deflist']);

function shallowEqual(a, b) {
  a = a || {};
  b = b || {};
  return Object.keys(a).length === Object.keys(b).length && Object.keys(a).every(k => a[k] === b[k]);
}

function extractInline(token) {
  const root = {
    t: 'inline',
    c: []
  };
  const stack = [root];
  let style = {};

  for (const child of token.children) {
    const current = stack[stack.length - 1];

    if (child.type === 'text') {
      current.c.push({
        t: 'text',
        v: child.content,
        p: {
          style
        }
      });
    } else if (child.type === 'softbreak') {
      current.c.push({
        t: 'softbreak'
      });
    } else if (child.type.endsWith('_open')) {
      const type = child.type.slice(0, -5);

      if (type === 'link') {
        const item = {
          t: 'link',
          c: [],
          p: {
            href: child.href,
            title: child.title
          }
        };
        current.c.push(item);
        stack.push(item);
      } else {
        style = { ...style,
          [type]: true
        };
      }
    } else if (child.type.endsWith('_close')) {
      const type = child.type.slice(0, -6);

      if (type === 'link') {
        stack.pop();
      } else {
        style = { ...style,
          [type]: false
        };
      }
    }
  }

  return root.c;
}

function cleanNode(node, depth = 0) {
  if (node.t === 'heading') {
    // drop all paragraphs
    node.c = node.c.filter(item => item.t !== 'paragraph');
  } else if (node.t === 'list_item') {
    var _node$p;

    // keep first paragraph as content of list_item, drop others
    node.c = node.c.filter(item => {
      if (item.t === 'paragraph') {
        if (!node.v.length) node.v.push(...item.v);
        return false;
      }

      return true;
    });

    if (((_node$p = node.p) == null ? void 0 : _node$p.index) != null) {
      node.v.unshift({
        t: 'text',
        v: `${node.p.index}. `
      });
    }
  } else if (node.t === 'ordered_list') {
    var _node$p$start, _node$p2;

    let index = (_node$p$start = (_node$p2 = node.p) == null ? void 0 : _node$p2.start) != null ? _node$p$start : 1;
    node.c.forEach(item => {
      if (item.t === 'list_item') {
        item.p = { ...item.p,
          index: index
        };
        index += 1;
      }
    });
  }

  if (node.c.length === 0) {
    delete node.c;
  } else {
    if (node.c.length === 1 && !node.c[0].v.length) {
      node.c = node.c[0].c;
    }

    node.c.forEach(child => cleanNode(child, depth + 1));
  }

  let last;
  const content = [];

  for (const item of node.v) {
    var _last, _last$p, _item$p;

    if (((_last = last) == null ? void 0 : _last.t) === 'text' && item.t === 'text' && shallowEqual((_last$p = last.p) == null ? void 0 : _last$p.style, (_item$p = item.p) == null ? void 0 : _item$p.style)) {
      last.v += item.v;
    } else {
      content.push(item);
    }

    last = item;
  }

  node.v = content;
  node.d = depth;
  delete node.p;
}

function buildTree(tokens) {
  // TODO deal with <dl><dt>
  const root = {
    t: 'root',
    d: 0,
    v: [],
    c: []
  };
  const stack = [root];
  let depth = 0;

  for (const token of tokens) {
    let current = stack[stack.length - 1];

    if (token.type.endsWith('_open')) {
      const type = token.type.slice(0, -5);
      const payload = {};

      if (type === 'heading') {
        depth = token.hLevel;

        while (((_current = current) == null ? void 0 : _current.d) >= depth) {
          var _current;

          stack.pop();
          current = stack[stack.length - 1];
        }
      } else {
        var _current2;

        depth = Math.max(depth, ((_current2 = current) == null ? void 0 : _current2.d) || 0) + 1;

        if (type === 'ordered_list') {
          payload.start = token.order;
        }
      }

      const item = {
        t: type,
        d: depth,
        v: [],
        p: payload,
        c: []
      };
      current.c.push(item);
      stack.push(item);
    } else if (!current) {
      continue;
    } else if (token.type === `${current.t}_close`) {
      if (current.t === 'heading') {
        depth = current.d;
      } else {
        stack.pop();
        depth = 0;
      }
    } else {
      current.v.push(...extractInline(token));
    }
  }

  return root;
}
function transform(content) {
  var _root$c;

  const tokens = md.parse(content || '', {});
  let root = buildTree(tokens);
  cleanNode(root);
  if (((_root$c = root.c) == null ? void 0 : _root$c.length) === 1) root = root.c[0];
  return root;
}

exports.buildTree = buildTree;
exports.transform = transform;
