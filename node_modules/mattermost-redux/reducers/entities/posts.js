"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeUnneededMetadata = removeUnneededMetadata;
exports.handlePosts = handlePosts;
exports.handlePendingPosts = handlePendingPosts;
exports.postsInChannel = postsInChannel;
exports.removeEmptyPostBlocks = removeEmptyPostBlocks;
exports.mergePostBlocks = mergePostBlocks;
exports.mergePostOrder = mergePostOrder;
exports.postsInThread = postsInThread;
exports.reactions = reactions;
exports.openGraph = openGraph;
exports.expandedURLs = expandedURLs;
exports.default = _default;

require("core-js/modules/es6.array.from");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es7.object.get-own-property-descriptors");

require("core-js/modules/es6.object.keys");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.string.iterator");

require("core-js/modules/es6.set");

require("core-js/modules/es7.array.includes");

require("core-js/modules/es6.string.includes");

require("core-js/modules/es6.array.find-index");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es7.object.values");

require("core-js/modules/es6.reflect.delete-property");

var _action_types = require("../../action_types");

var _constants = require("../../constants");

var _post_utils = require("../../utils/post_utils");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function removeUnneededMetadata(post) {
  if (!post.metadata) {
    return post;
  }

  var metadata = _objectSpread({}, post.metadata);

  var changed = false; // These fields are stored separately

  if (metadata.emojis) {
    Reflect.deleteProperty(metadata, 'emojis');
    changed = true;
  }

  if (metadata.files) {
    Reflect.deleteProperty(metadata, 'files');
    changed = true;
  }

  if (metadata.reactions) {
    Reflect.deleteProperty(metadata, 'reactions');
    changed = true;
  }

  if (metadata.embeds) {
    var embedsChanged = false;
    var newEmbeds = metadata.embeds.map(function (embed) {
      if (embed.type !== 'opengraph') {
        return embed;
      }

      var newEmbed = _objectSpread({}, embed);

      Reflect.deleteProperty(newEmbed, 'data');
      embedsChanged = true;
      return newEmbed;
    });

    if (embedsChanged) {
      metadata.embeds = newEmbeds;
      changed = true;
    }
  }

  if (!changed) {
    // Nothing changed
    return post;
  }

  return _objectSpread({}, post, {
    metadata: metadata
  });
}

function handlePosts() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.RECEIVED_POST:
    case _action_types.PostTypes.RECEIVED_NEW_POST:
      {
        return handlePostReceived(_objectSpread({}, state), action.data);
      }

    case _action_types.PostTypes.RECEIVED_POSTS:
      {
        var posts = Object.values(action.data.posts);

        if (posts.length === 0) {
          return state;
        }

        var nextState = _objectSpread({}, state);

        for (var _i = 0, _posts = posts; _i < _posts.length; _i++) {
          var post = _posts[_i];
          handlePostReceived(nextState, post);
        }

        return nextState;
      }

    case _action_types.PostTypes.POST_DELETED:
      {
        var _post = action.data;

        if (!state[_post.id]) {
          return state;
        } // Mark the post as deleted


        var _nextState = _objectSpread({}, state, _defineProperty({}, _post.id, _objectSpread({}, state[_post.id], {
          state: _constants.Posts.POST_DELETED,
          file_ids: [],
          has_reactions: false
        }))); // Remove any of its comments


        for (var _i2 = 0, _Object$values = Object.values(state); _i2 < _Object$values.length; _i2++) {
          var otherPost = _Object$values[_i2];

          if (otherPost.root_id === _post.id) {
            Reflect.deleteProperty(_nextState, otherPost.id);
          }
        }

        return _nextState;
      }

    case _action_types.PostTypes.POST_REMOVED:
      {
        var _post2 = action.data;

        if (!state[_post2.id]) {
          return state;
        } // Remove the post itself


        var _nextState2 = _objectSpread({}, state);

        Reflect.deleteProperty(_nextState2, _post2.id); // Remove any of its comments

        for (var _i3 = 0, _Object$values2 = Object.values(state); _i3 < _Object$values2.length; _i3++) {
          var _otherPost = _Object$values2[_i3];

          if (_otherPost.root_id === _post2.id) {
            Reflect.deleteProperty(_nextState2, _otherPost.id);
          }
        }

        return _nextState2;
      }

    case _action_types.ChannelTypes.RECEIVED_CHANNEL_DELETED:
    case _action_types.ChannelTypes.DELETE_CHANNEL_SUCCESS:
    case _action_types.ChannelTypes.LEAVE_CHANNEL:
      {
        if (action.data && action.data.viewArchivedChannels) {
          // Nothing to do since we still want to store posts in archived channels
          return state;
        }

        var channelId = action.data.id;
        var postDeleted = false; // Remove any posts in the deleted channel

        var _nextState3 = _objectSpread({}, state);

        for (var _i4 = 0, _Object$values3 = Object.values(state); _i4 < _Object$values3.length; _i4++) {
          var _post3 = _Object$values3[_i4];

          if (_post3.channel_id === channelId) {
            Reflect.deleteProperty(_nextState3, _post3.id);
            postDeleted = true;
          }
        }

        if (!postDeleted) {
          // Nothing changed
          return state;
        }

        return _nextState3;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function handlePostReceived(nextState, post) {
  if (nextState[post.id] && nextState[post.id].update_at >= post.update_at) {
    // The stored post is newer than the one we've received
    return nextState;
  }

  if (post.delete_at > 0) {
    // We've received a deleted post, so mark the post as deleted if we already have it
    if (nextState[post.id]) {
      nextState[post.id] = _objectSpread({}, removeUnneededMetadata(post), {
        state: _constants.Posts.POST_DELETED,
        file_ids: [],
        has_reactions: false
      });
    }
  } else {
    nextState[post.id] = removeUnneededMetadata(post);
  } // Delete any pending post that existed for this post


  if (post.pending_post_id && post.id !== post.pending_post_id && nextState[post.pending_post_id]) {
    Reflect.deleteProperty(nextState, post.pending_post_id);
  }

  return nextState;
}

function handlePendingPosts() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.RECEIVED_NEW_POST:
      {
        var post = action.data;

        if (!post.pending_post_id) {
          // This is not a pending post
          return state;
        }

        var index = state.indexOf(post.pending_post_id);

        if (index !== -1) {
          // An entry already exists for this post
          return state;
        } // Add the new pending post ID


        var nextState = _toConsumableArray(state);

        nextState.push(post.pending_post_id);
        return nextState;
      }

    case _action_types.PostTypes.POST_REMOVED:
      {
        var _post4 = action.data;

        var _index = state.indexOf(_post4.id);

        if (_index === -1) {
          // There's nothing to remove
          return state;
        } // The post has been removed, so remove the entry for it


        var _nextState4 = _toConsumableArray(state);

        _nextState4.splice(_index, 1);

        return _nextState4;
      }

    case _action_types.PostTypes.RECEIVED_POST:
      {
        var _post5 = action.data;

        if (!_post5.pending_post_id) {
          // This isn't a pending post
          return state;
        }

        var _index2 = state.indexOf(_post5.pending_post_id);

        if (_index2 === -1) {
          // There's nothing to remove
          return state;
        } // The post has actually been created, so remove the entry for it


        var _nextState5 = _toConsumableArray(state);

        _nextState5.splice(_index2, 1);

        return _nextState5;
      }

    default:
      return state;
  }
}

function postsInChannel() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var prevPosts = arguments.length > 2 ? arguments[2] : undefined;
  var nextPosts = arguments.length > 3 ? arguments[3] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.RECEIVED_NEW_POST:
      {
        var post = action.data;
        var postsForChannel = state[post.channel_id];

        if (!postsForChannel) {
          // Don't save newly created posts until the channel has been loaded
          return state;
        }

        var recentBlockIndex = postsForChannel.findIndex(function (block) {
          return block.recent;
        });

        if (recentBlockIndex === -1 && postsForChannel.length > 0) {
          // Don't save newly created posts until the most recent posts for the channel have been loaded, unless
          // the channel is completely empty
          return state;
        }

        var nextRecentBlock;

        if (recentBlockIndex === -1) {
          nextRecentBlock = {
            order: [],
            recent: true
          };
        } else {
          var recentBlock = postsForChannel[recentBlockIndex];
          nextRecentBlock = _objectSpread({}, recentBlock, {
            order: _toConsumableArray(recentBlock.order)
          });
        }

        var changed = false; // Add the new post to the channel

        if (!nextRecentBlock.order.includes(post.id)) {
          nextRecentBlock.order.unshift(post.id);
          changed = true;
        } // If this is a newly created post, remove any pending post that exists for it


        if (post.pending_post_id && post.id !== post.pending_post_id) {
          var index = nextRecentBlock.order.indexOf(post.pending_post_id);

          if (index !== -1) {
            nextRecentBlock.order.splice(index, 1);
            changed = true;
          }
        }

        if (!changed) {
          return state;
        }

        var nextPostsForChannel = _toConsumableArray(postsForChannel);

        if (recentBlockIndex === -1) {
          nextPostsForChannel.push(nextRecentBlock);
        } else {
          nextPostsForChannel[recentBlockIndex] = nextRecentBlock;
        }

        return _objectSpread({}, state, _defineProperty({}, post.channel_id, nextPostsForChannel));
      }

    case _action_types.PostTypes.RECEIVED_POST:
      {
        var _post6 = action.data; // Receiving a single post doesn't usually affect the order of posts in a channel, except for when we've
        // received a newly created post that was previously stored as pending

        if (!_post6.pending_post_id) {
          return state;
        }

        var _postsForChannel = state[_post6.channel_id] || [];

        var _recentBlockIndex = _postsForChannel.findIndex(function (block) {
          return block.recent;
        });

        if (_recentBlockIndex === -1) {
          // Nothing to do since there's no recent block and only the recent block should contain pending posts
          return state;
        }

        var _recentBlock = _postsForChannel[_recentBlockIndex]; // Replace the pending post with the newly created one

        var _index3 = _recentBlock.order.indexOf(_post6.pending_post_id);

        if (_index3 === -1) {
          // No pending post found to remove
          return state;
        }

        var _nextRecentBlock = _objectSpread({}, _recentBlock, {
          order: _toConsumableArray(_recentBlock.order)
        });

        _nextRecentBlock.order[_index3] = _post6.id;

        var _nextPostsForChannel = _toConsumableArray(_postsForChannel);

        _nextPostsForChannel[_recentBlockIndex] = _nextRecentBlock;
        return _objectSpread({}, state, _defineProperty({}, _post6.channel_id, _nextPostsForChannel));
      }

    case _action_types.PostTypes.RECEIVED_POSTS_IN_CHANNEL:
      {
        var recent = action.recent;
        var order = action.data.order;

        if (order.length === 0 && state[action.channelId]) {
          // No new posts received when we already have posts
          return state;
        }

        var _postsForChannel2 = state[action.channelId] || [];

        var _nextPostsForChannel2 = _toConsumableArray(_postsForChannel2);

        if (recent) {
          // The newly received block is now the most recent, so unmark the current most recent block
          var _recentBlockIndex2 = _postsForChannel2.findIndex(function (block) {
            return block.recent;
          });

          if (_recentBlockIndex2 !== -1) {
            var _recentBlock2 = _postsForChannel2[_recentBlockIndex2];

            if (_recentBlock2.order.length === order.length && _recentBlock2.order[0] === order[0] && _recentBlock2.order[_recentBlock2.order.length - 1] === order[order.length - 1]) {
              // The newly received posts are identical to the most recent block, so there's nothing to do
              return state;
            } // Unmark the most recent block since the new posts are more recent


            var _nextRecentBlock2 = _objectSpread({}, _recentBlock2, {
              recent: false
            });

            _nextPostsForChannel2[_recentBlockIndex2] = _nextRecentBlock2;
          }
        } // Add the new most recent block


        _nextPostsForChannel2.push({
          order: order,
          recent: recent
        }); // Merge overlapping blocks


        _nextPostsForChannel2 = mergePostBlocks(_nextPostsForChannel2, nextPosts);
        return _objectSpread({}, state, _defineProperty({}, action.channelId, _nextPostsForChannel2));
      }

    case _action_types.PostTypes.RECEIVED_POSTS_AFTER:
      {
        var _order = action.data.order;
        var afterPostId = action.afterPostId;

        if (_order.length === 0) {
          // No posts received
          return state;
        }

        var _postsForChannel3 = state[action.channelId] || []; // Add a new block including the previous post and then have mergePostBlocks sort out any overlap or duplicates


        var newBlock = {
          order: [].concat(_toConsumableArray(_order), [afterPostId]),
          recent: false
        };

        var _nextPostsForChannel3 = [].concat(_toConsumableArray(_postsForChannel3), [newBlock]);

        _nextPostsForChannel3 = mergePostBlocks(_nextPostsForChannel3, nextPosts);
        return _objectSpread({}, state, _defineProperty({}, action.channelId, _nextPostsForChannel3));
      }

    case _action_types.PostTypes.RECEIVED_POSTS_BEFORE:
      {
        var _order2 = action.data.order;
        var beforePostId = action.beforePostId;

        if (_order2.length === 0) {
          // No posts received
          return state;
        }

        var _postsForChannel4 = state[action.channelId] || []; // Add a new block including the next post and then have mergePostBlocks sort out any overlap or duplicates


        var _newBlock = {
          order: [beforePostId].concat(_toConsumableArray(_order2)),
          recent: false
        };

        var _nextPostsForChannel4 = [].concat(_toConsumableArray(_postsForChannel4), [_newBlock]);

        _nextPostsForChannel4 = mergePostBlocks(_nextPostsForChannel4, nextPosts);
        return _objectSpread({}, state, _defineProperty({}, action.channelId, _nextPostsForChannel4));
      }

    case _action_types.PostTypes.RECEIVED_POSTS_SINCE:
      {
        var _order3 = action.data.order;

        if (_order3.length === 0 && state[action.channelId]) {
          // No new posts received when we already have posts
          return state;
        }

        var _postsForChannel5 = state[action.channelId] || [];

        var _recentBlockIndex3 = _postsForChannel5.findIndex(function (block) {
          return block.recent;
        });

        if (_recentBlockIndex3 === -1) {
          // Nothing to do since this shouldn't be dispatched if we haven't loaded the most recent posts yet
          return state;
        }

        var _recentBlock3 = _postsForChannel5[_recentBlockIndex3];
        var mostOldestCreateAt = nextPosts[_recentBlock3.order[_recentBlock3.order.length - 1]].create_at;

        var _nextRecentBlock3 = _objectSpread({}, _recentBlock3, {
          order: _toConsumableArray(_recentBlock3.order)
        }); // Add any new posts to the most recent block while skipping ones that were only updated


        for (var i = _order3.length - 1; i >= 0; i--) {
          var postId = _order3[i];

          if (!nextPosts[postId]) {
            // the post was removed from the list
            continue;
          }

          if (nextPosts[postId].create_at <= mostOldestCreateAt) {
            // This is an old post
            continue;
          }

          if (_nextRecentBlock3.order.indexOf(postId) !== -1) {
            // This postId exists so no need to add it again
            continue;
          } // This post is newer than what we have


          _nextRecentBlock3.order.unshift(postId);
        }

        if (_nextRecentBlock3.order.length === _recentBlock3.order.length) {
          // Nothing was added
          return state;
        }

        _nextRecentBlock3.order.sort(function (a, b) {
          return (0, _post_utils.comparePosts)(nextPosts[a], nextPosts[b]);
        });

        var _nextPostsForChannel5 = _toConsumableArray(_postsForChannel5);

        _nextPostsForChannel5[_recentBlockIndex3] = _nextRecentBlock3;
        return _objectSpread({}, state, _defineProperty({}, action.channelId, _nextPostsForChannel5));
      }

    case _action_types.PostTypes.POST_DELETED:
      {
        var _ret = function () {
          var post = action.data; // Deleting a post removes its comments from the order, but does not remove the post itself

          var postsForChannel = state[post.channel_id] || [];

          if (postsForChannel.length === 0) {
            return {
              v: state
            };
          }

          var changed = false;

          var nextPostsForChannel = _toConsumableArray(postsForChannel);

          for (var _i5 = 0; _i5 < nextPostsForChannel.length; _i5++) {
            var block = nextPostsForChannel[_i5]; // Remove any comments for this post

            var nextOrder = block.order.filter(function (postId) {
              return prevPosts[postId].root_id !== post.id;
            });

            if (nextOrder.length !== block.order.length) {
              nextPostsForChannel[_i5] = _objectSpread({}, block, {
                order: nextOrder
              });
              changed = true;
            }
          }

          if (!changed) {
            // Nothing was removed
            return {
              v: state
            };
          }

          nextPostsForChannel = removeEmptyPostBlocks(nextPostsForChannel);
          return {
            v: _objectSpread({}, state, _defineProperty({}, post.channel_id, nextPostsForChannel))
          };
        }();

        if (_typeof(_ret) === "object") return _ret.v;
      }

    case _action_types.PostTypes.POST_REMOVED:
      {
        var _ret2 = function () {
          var post = action.data; // Removing a post removes it as well as its comments

          var postsForChannel = state[post.channel_id] || [];

          if (postsForChannel.length === 0) {
            return {
              v: state
            };
          }

          var changed = false; // Remove the post and its comments from the channel

          var nextPostsForChannel = _toConsumableArray(postsForChannel);

          for (var _i6 = 0; _i6 < nextPostsForChannel.length; _i6++) {
            var block = nextPostsForChannel[_i6];
            var nextOrder = block.order.filter(function (postId) {
              return postId !== post.id && prevPosts[postId].root_id !== post.id;
            });

            if (nextOrder.length !== block.order.length) {
              nextPostsForChannel[_i6] = _objectSpread({}, block, {
                order: nextOrder
              });
              changed = true;
            }
          }

          if (!changed) {
            // Nothing was removed
            return {
              v: state
            };
          }

          nextPostsForChannel = removeEmptyPostBlocks(nextPostsForChannel);
          return {
            v: _objectSpread({}, state, _defineProperty({}, post.channel_id, nextPostsForChannel))
          };
        }();

        if (_typeof(_ret2) === "object") return _ret2.v;
      }

    case _action_types.ChannelTypes.RECEIVED_CHANNEL_DELETED:
    case _action_types.ChannelTypes.DELETE_CHANNEL_SUCCESS:
    case _action_types.ChannelTypes.LEAVE_CHANNEL:
      {
        if (action.data && action.data.viewArchivedChannels) {
          // Nothing to do since we still want to store posts in archived channels
          return state;
        }

        var channelId = action.data.id;

        if (!state[channelId]) {
          // Nothing to do since we have no posts for this channel
          return state;
        } // Remove the entry for the deleted channel


        var nextState = _objectSpread({}, state);

        Reflect.deleteProperty(nextState, channelId);
        return nextState;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function removeEmptyPostBlocks(blocks) {
  return blocks.filter(function (block) {
    return block.order.length !== 0;
  });
}

function mergePostBlocks(blocks, posts) {
  var nextBlocks = _toConsumableArray(blocks); // Remove any blocks that may have become empty by removing posts


  nextBlocks = removeEmptyPostBlocks(blocks); // Sort blocks so that the most recent one comes first

  nextBlocks.sort(function (a, b) {
    var aStartsAt = posts[a.order[0]].create_at;
    var bStartsAt = posts[b.order[0]].create_at;
    return bStartsAt - aStartsAt;
  }); // Merge adjacent blocks

  var i = 0;

  while (i < nextBlocks.length - 1) {
    // Since we know the start of a is more recent than the start of b, they'll overlap if the last post in a is
    // older than the first post in b
    var a = nextBlocks[i];
    var aEndsAt = posts[a.order[a.order.length - 1]].create_at;
    var b = nextBlocks[i + 1];
    var bStartsAt = posts[b.order[0]].create_at;

    if (aEndsAt <= bStartsAt) {
      // The blocks overlap, so combine them and remove the second block
      nextBlocks[i] = {
        order: mergePostOrder(a.order, b.order, posts)
      };
      nextBlocks[i].recent = a.recent || b.recent;
      nextBlocks.splice(i + 1, 1); // Do another iteration on this index since it may need to be merged into the next
    } else {
      // The blocks don't overlap, so move on to the next one
      i += 1;
    }
  }

  if (blocks.length === nextBlocks.length) {
    // No changes were made
    return blocks;
  }

  return nextBlocks;
}

function mergePostOrder(left, right, posts) {
  var result = _toConsumableArray(left); // Add without duplicates


  var seen = new Set(left);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = right[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var id = _step.value;

      if (seen.has(id)) {
        continue;
      }

      result.push(id);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (result.length === left.length) {
    // No new items added
    return left;
  } // Re-sort so that the most recent post comes first


  result.sort(function (a, b) {
    return posts[b].create_at - posts[a].create_at;
  });
  return result;
}

function postsInThread() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var prevPosts = arguments.length > 2 ? arguments[2] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.RECEIVED_NEW_POST:
    case _action_types.PostTypes.RECEIVED_POST:
      {
        var post = action.data;

        if (!post.root_id) {
          // Only store comments, not the root post
          return state;
        }

        var postsForThread = state[post.root_id] || [];

        var nextPostsForThread = _toConsumableArray(postsForThread);

        var changed = false;

        if (!postsForThread.includes(post.id)) {
          nextPostsForThread.push(post.id);
          changed = true;
        } // If this is a new non-pending post, remove any pending post that exists for it


        if (post.pending_post_id && post.id !== post.pending_post_id) {
          var index = nextPostsForThread.indexOf(post.pending_post_id);

          if (index !== -1) {
            nextPostsForThread.splice(index, 1);
            changed = true;
          }
        }

        if (!changed) {
          return state;
        }

        return _objectSpread({}, state, _defineProperty({}, post.root_id, nextPostsForThread));
      }

    case _action_types.PostTypes.RECEIVED_POSTS_AFTER:
    case _action_types.PostTypes.RECEIVED_POSTS_BEFORE:
    case _action_types.PostTypes.RECEIVED_POSTS_IN_CHANNEL:
    case _action_types.PostTypes.RECEIVED_POSTS_SINCE:
      {
        var newPosts = Object.values(action.data.posts);

        if (newPosts.length === 0) {
          // Nothing to add
          return state;
        }

        var nextState = {};

        for (var _i7 = 0, _newPosts = newPosts; _i7 < _newPosts.length; _i7++) {
          var _post7 = _newPosts[_i7];

          if (!_post7.root_id) {
            // Only store comments, not the root post
            continue;
          }

          var _postsForThread = state[_post7.root_id] || [];

          var _nextPostsForThread = nextState[_post7.root_id] || _toConsumableArray(_postsForThread); // Add the post to the thread


          if (!_nextPostsForThread.includes(_post7.id)) {
            _nextPostsForThread.push(_post7.id);
          }

          nextState[_post7.root_id] = _nextPostsForThread;
        }

        if (Object.keys(nextState).length === 0) {
          return state;
        }

        return _objectSpread({}, state, {}, nextState);
      }

    case _action_types.PostTypes.RECEIVED_POSTS_IN_THREAD:
      {
        var _newPosts2 = Object.values(action.data.posts);

        if (_newPosts2.length === 0) {
          // Nothing to add
          return state;
        }

        var _postsForThread2 = state[action.rootId] || [];

        var _nextPostsForThread2 = _toConsumableArray(_postsForThread2);

        for (var _i8 = 0, _newPosts3 = _newPosts2; _i8 < _newPosts3.length; _i8++) {
          var _post8 = _newPosts3[_i8];

          if (_post8.root_id !== action.rootId) {
            // Only store comments
            continue;
          }

          if (_nextPostsForThread2.includes(_post8.id)) {
            // Don't store duplicates
            continue;
          }

          _nextPostsForThread2.push(_post8.id);
        }

        return _objectSpread({}, state, _defineProperty({}, action.rootId, _nextPostsForThread2));
      }

    case _action_types.PostTypes.POST_DELETED:
      {
        var _post9 = action.data;
        var _postsForThread3 = state[_post9.id];

        if (!_postsForThread3) {
          // Nothing to remove
          return state;
        }

        var _nextState6 = _objectSpread({}, state);

        Reflect.deleteProperty(_nextState6, _post9.id);
        return _nextState6;
      }

    case _action_types.PostTypes.POST_REMOVED:
      {
        var _post10 = action.data;

        if (_post10.root_id) {
          // This is a comment, so remove it from the thread
          var _postsForThread5 = state[_post10.root_id];

          if (!_postsForThread5) {
            return state;
          }

          var _index4 = _postsForThread5.findIndex(function (postId) {
            return postId === _post10.id;
          });

          if (_index4 === -1) {
            return state;
          }

          var _nextPostsForThread3 = _toConsumableArray(_postsForThread5);

          _nextPostsForThread3.splice(_index4, 1);

          return _objectSpread({}, state, _defineProperty({}, _post10.root_id, _nextPostsForThread3));
        } // This is not a comment, so remove any comments on it


        var _postsForThread4 = state[_post10.id];

        if (!_postsForThread4) {
          return state;
        }

        var _nextState7 = _objectSpread({}, state);

        Reflect.deleteProperty(_nextState7, _post10.id);
        return _nextState7;
      }

    case _action_types.ChannelTypes.RECEIVED_CHANNEL_DELETED:
    case _action_types.ChannelTypes.DELETE_CHANNEL_SUCCESS:
    case _action_types.ChannelTypes.LEAVE_CHANNEL:
      {
        if (action.data && action.data.viewArchivedChannels) {
          // Nothing to do since we still want to store posts in archived channels
          return state;
        }

        var channelId = action.data.id;
        var postDeleted = false; // Remove entries for any thread in the channel

        var _nextState8 = _objectSpread({}, state);

        for (var _i9 = 0, _Object$keys = Object.keys(state); _i9 < _Object$keys.length; _i9++) {
          var rootId = _Object$keys[_i9];

          if (prevPosts[rootId] && prevPosts[rootId].channel_id === channelId) {
            Reflect.deleteProperty(_nextState8, rootId);
            postDeleted = true;
          }
        }

        if (!postDeleted) {
          // Nothing was actually removed
          return state;
        }

        return _nextState8;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function selectedPostId() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.RECEIVED_POST_SELECTED:
      return action.data;

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return '';

    default:
      return state;
  }
}

function currentFocusedPostId() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.RECEIVED_FOCUSED_POST:
      return action.data;

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return '';

    default:
      return state;
  }
}

function reactions() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.RECEIVED_REACTIONS:
      {
        var reactionsList = action.data;
        var nextReactions = {};
        reactionsList.forEach(function (reaction) {
          nextReactions[reaction.user_id + '-' + reaction.emoji_name] = reaction;
        });
        return _objectSpread({}, state, _defineProperty({}, action.postId, nextReactions));
      }

    case _action_types.PostTypes.RECEIVED_REACTION:
      {
        var reaction = action.data;

        var _nextReactions = _objectSpread({}, state[reaction.post_id] || {});

        _nextReactions[reaction.user_id + '-' + reaction.emoji_name] = reaction;
        return _objectSpread({}, state, _defineProperty({}, reaction.post_id, _nextReactions));
      }

    case _action_types.PostTypes.REACTION_DELETED:
      {
        var _reaction = action.data;

        var _nextReactions2 = _objectSpread({}, state[_reaction.post_id] || {});

        if (!_nextReactions2[_reaction.user_id + '-' + _reaction.emoji_name]) {
          return state;
        }

        Reflect.deleteProperty(_nextReactions2, _reaction.user_id + '-' + _reaction.emoji_name);
        return _objectSpread({}, state, _defineProperty({}, _reaction.post_id, _nextReactions2));
      }

    case _action_types.PostTypes.RECEIVED_NEW_POST:
    case _action_types.PostTypes.RECEIVED_POST:
      {
        var post = action.data;
        return storeReactionsForPost(state, post);
      }

    case _action_types.PostTypes.RECEIVED_POSTS:
      {
        var posts = Object.values(action.data.posts);
        return posts.reduce(storeReactionsForPost, state);
      }

    case _action_types.PostTypes.POST_DELETED:
    case _action_types.PostTypes.POST_REMOVED:
      {
        var _post11 = action.data;

        if (_post11 && state[_post11.id]) {
          var nextState = _objectSpread({}, state);

          Reflect.deleteProperty(nextState, _post11.id);
          return nextState;
        }

        return state;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function storeReactionsForPost(state, post) {
  if (!post.metadata || !post.metadata.reactions) {
    return state;
  }

  var reactionsForPost = {};

  if (post.metadata.reactions && post.metadata.reactions.length > 0) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = post.metadata.reactions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var reaction = _step2.value;
        reactionsForPost[reaction.user_id + '-' + reaction.emoji_name] = reaction;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  return _objectSpread({}, state, _defineProperty({}, post.id, reactionsForPost));
}

function openGraph() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.RECEIVED_OPEN_GRAPH_METADATA:
      {
        var nextState = _objectSpread({}, state);

        nextState[action.url] = action.data;
        return nextState;
      }

    case _action_types.PostTypes.RECEIVED_NEW_POST:
    case _action_types.PostTypes.RECEIVED_POST:
      {
        var post = action.data;
        return storeOpenGraphForPost(state, post);
      }

    case _action_types.PostTypes.RECEIVED_POSTS:
      {
        var posts = Object.values(action.data.posts);
        return posts.reduce(storeOpenGraphForPost, state);
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function storeOpenGraphForPost(state, post) {
  if (!post.metadata || !post.metadata.embeds) {
    return state;
  }

  return post.metadata.embeds.reduce(function (nextState, embed) {
    if (embed.type !== 'opengraph' || !embed.data) {
      // Not an OpenGraph embed
      return nextState;
    }

    return _objectSpread({}, nextState, _defineProperty({}, embed.url, embed.data));
  }, state);
}

function messagesHistory() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _action_types.PostTypes.ADD_MESSAGE_INTO_HISTORY:
      {
        var nextIndex = {};
        var nextMessages = state.messages ? _toConsumableArray(state.messages) : [];
        nextMessages.push(action.data);
        nextIndex[_constants.Posts.MESSAGE_TYPES.POST] = nextMessages.length;
        nextIndex[_constants.Posts.MESSAGE_TYPES.COMMENT] = nextMessages.length;

        if (nextMessages.length > _constants.Posts.MAX_PREV_MSGS) {
          nextMessages = nextMessages.slice(1, _constants.Posts.MAX_PREV_MSGS + 1);
        }

        return {
          messages: nextMessages,
          index: nextIndex
        };
      }

    case _action_types.PostTypes.RESET_HISTORY_INDEX:
      {
        var index = {};
        index[_constants.Posts.MESSAGE_TYPES.POST] = -1;
        index[_constants.Posts.MESSAGE_TYPES.COMMENT] = -1;
        var messages = state.messages || [];

        var _nextIndex = state.index ? _objectSpread({}, state.index) : index;

        _nextIndex[action.data] = messages.length;
        return {
          messages: state.messages,
          index: _nextIndex
        };
      }

    case _action_types.PostTypes.MOVE_HISTORY_INDEX_BACK:
      {
        var _index5 = {};
        _index5[_constants.Posts.MESSAGE_TYPES.POST] = -1;
        _index5[_constants.Posts.MESSAGE_TYPES.COMMENT] = -1;

        var _nextIndex2 = state.index ? _objectSpread({}, state.index) : _index5;

        if (_nextIndex2[action.data] > 0) {
          _nextIndex2[action.data]--;
        }

        return {
          messages: state.messages,
          index: _nextIndex2
        };
      }

    case _action_types.PostTypes.MOVE_HISTORY_INDEX_FORWARD:
      {
        var _index6 = {};
        _index6[_constants.Posts.MESSAGE_TYPES.POST] = -1;
        _index6[_constants.Posts.MESSAGE_TYPES.COMMENT] = -1;

        var _messages = state.messages || [];

        var _nextIndex3 = state.index ? _objectSpread({}, state.index) : _index6;

        if (_nextIndex3[action.data] < _messages.length) {
          _nextIndex3[action.data]++;
        }

        return {
          messages: state.messages,
          index: _nextIndex3
        };
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      {
        var _index7 = {};
        _index7[_constants.Posts.MESSAGE_TYPES.POST] = -1;
        _index7[_constants.Posts.MESSAGE_TYPES.COMMENT] = -1;
        return {
          messages: [],
          index: _index7
        };
      }

    default:
      return state;
  }
}

function expandedURLs() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _action_types.GeneralTypes.REDIRECT_LOCATION_SUCCESS:
      return _objectSpread({}, state, _defineProperty({}, action.data.url, action.data.location));

    case _action_types.GeneralTypes.REDIRECT_LOCATION_FAILURE:
      return _objectSpread({}, state, _defineProperty({}, action.data.url, action.data.url));

    default:
      return state;
  }
}

function _default() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var nextPosts = handlePosts(state.posts, action);
  var nextPostsInChannel = postsInChannel(state.postsInChannel, action, state.posts, nextPosts);
  var nextState = {
    // Object mapping post ids to post objects
    posts: nextPosts,
    // Array that contains the pending post ids for those messages that are in transition to being created
    pendingPostIds: handlePendingPosts(state.pendingPostIds, action),
    // Object mapping channel ids to an array of posts ids in that channel with the most recent post first
    postsInChannel: nextPostsInChannel,
    // Object mapping post root ids to an array of posts ids of comments (but not the root post) in that thread
    // with no guaranteed order
    postsInThread: postsInThread(state.postsInThread, action, state.posts),
    // The current selected post
    selectedPostId: selectedPostId(state.selectedPostId, action),
    // The current selected focused post (permalink view)
    currentFocusedPostId: currentFocusedPostId(state.currentFocusedPostId, action),
    // Object mapping post ids to an object of emoji reactions using userId-emojiName as keys
    reactions: reactions(state.reactions, action),
    // Object mapping URLs to their relevant opengraph metadata for link previews
    openGraph: openGraph(state.openGraph, action),
    // History of posts and comments
    messagesHistory: messagesHistory(state.messagesHistory, action),
    expandedURLs: expandedURLs(state.expandedURLs, action)
  };

  if (state.posts === nextState.posts && state.postsInChannel === nextState.postsInChannel && state.postsInThread === nextState.postsInThread && state.pendingPostIds === nextState.pendingPostIds && state.selectedPostId === nextState.selectedPostId && state.currentFocusedPostId === nextState.currentFocusedPostId && state.reactions === nextState.reactions && state.openGraph === nextState.openGraph && state.messagesHistory === nextState.messagesHistory && state.expandedURLs === nextState.expandedURLs) {
    // None of the children have changed so don't even let the parent object change
    return state;
  }

  return nextState;
}