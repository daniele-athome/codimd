"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPostFlagged = isPostFlagged;
exports.isSystemMessage = isSystemMessage;
exports.isFromWebhook = isFromWebhook;
exports.isPostEphemeral = isPostEphemeral;
exports.shouldIgnorePost = shouldIgnorePost;
exports.isUserActivityPost = isUserActivityPost;
exports.isPostOwner = isPostOwner;
exports.isEdited = isEdited;
exports.canDeletePost = canDeletePost;
exports.canEditPost = canEditPost;
exports.getLastCreateAt = getLastCreateAt;
exports.shouldFilterJoinLeavePost = shouldFilterJoinLeavePost;
exports.isPostPendingOrFailed = isPostPendingOrFailed;
exports.comparePosts = comparePosts;
exports.isPostCommentMention = isPostCommentMention;
exports.fromAutoResponder = fromAutoResponder;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.reflect.apply");

require("core-js/modules/es7.array.includes");

require("core-js/modules/es6.string.includes");

require("core-js/modules/es6.string.starts-with");

var _constants = require("../constants");

var _general = require("../selectors/entities/general");

var _roles = require("../selectors/entities/roles");

var _preference_utils = require("./preference_utils");

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow
function isPostFlagged(postId
/*: $ID<Post>*/
, myPreferences
/*: {[string]: PreferenceType}*/
)
/*: boolean*/
{
  var key = (0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_FLAGGED_POST, postId);
  return myPreferences.hasOwnProperty(key);
}

function isSystemMessage(post
/*: Post*/
)
/*: boolean*/
{
  return Boolean(post.type && post.type.startsWith(_constants.Posts.SYSTEM_MESSAGE_PREFIX));
}

function isFromWebhook(post
/*: Post*/
)
/*: boolean*/
{
  return post.props && post.props.from_webhook;
}

function isPostEphemeral(post
/*: Post*/
)
/*: boolean*/
{
  return post.type === _constants.Posts.POST_TYPES.EPHEMERAL || post.type === _constants.Posts.POST_TYPES.EPHEMERAL_ADD_TO_CHANNEL || post.state === _constants.Posts.POST_DELETED;
}

function shouldIgnorePost(post
/*: Post*/
)
/*: boolean*/
{
  return _constants.Posts.IGNORE_POST_TYPES.includes(post.type);
}

function isUserActivityPost(postType
/*: PostType*/
)
/*: boolean*/
{
  return _constants.Posts.USER_ACTIVITY_POST_TYPES.includes(postType);
}

function isPostOwner(userId
/*: $ID<UserProfile>*/
, post
/*: Post*/
) {
  return userId === post.user_id;
}

function isEdited(post
/*: Post*/
)
/*: boolean*/
{
  return post.edit_at > 0;
}

function canDeletePost(state
/*: GlobalState*/
, config
/*: Object*/
, license
/*: Object*/
, teamId
/*: $ID<Team>*/
, channelId
/*: $ID<Channel>*/
, userId
/*: $ID<UserProfile>*/
, post
/*: Post*/
, isAdmin
/*: boolean*/
, isSystemAdmin
/*: boolean*/
)
/*: boolean*/
{
  if (!post) {
    return false;
  }

  var isOwner = isPostOwner(userId, post);

  if ((0, _general.hasNewPermissions)(state)) {
    var canDelete = (0, _roles.haveIChannelPermission)(state, {
      team: teamId,
      channel: channelId,
      permission: _constants.Permissions.DELETE_POST
    });

    if (!isOwner) {
      return canDelete && (0, _roles.haveIChannelPermission)(state, {
        team: teamId,
        channel: channelId,
        permission: _constants.Permissions.DELETE_OTHERS_POSTS
      });
    }

    return canDelete;
  } // Backwards compatibility with pre-advanced permissions config settings.


  if (license.IsLicensed === 'true') {
    return config.RestrictPostDelete === _constants.General.PERMISSIONS_ALL && (isOwner || isAdmin) || config.RestrictPostDelete === _constants.General.PERMISSIONS_TEAM_ADMIN && isAdmin || config.RestrictPostDelete === _constants.General.PERMISSIONS_SYSTEM_ADMIN && isSystemAdmin;
  }

  return isOwner || isAdmin;
}

function canEditPost(state
/*: GlobalState*/
, config
/*: Object*/
, license
/*: Object*/
, teamId
/*: $ID<Team>*/
, channelId
/*: $ID<Channel>*/
, userId
/*: $ID<UserProfile>*/
, post
/*: Post*/
)
/*: boolean*/
{
  if (!post || isSystemMessage(post)) {
    return false;
  }

  var isOwner = isPostOwner(userId, post);
  var canEdit = true;

  if ((0, _general.hasNewPermissions)(state)) {
    canEdit = canEdit && (0, _roles.haveIChannelPermission)(state, {
      team: teamId,
      channel: channelId,
      permission: _constants.Permissions.EDIT_POST
    });

    if (!isOwner) {
      canEdit = canEdit && (0, _roles.haveIChannelPermission)(state, {
        team: teamId,
        channel: channelId,
        permission: _constants.Permissions.EDIT_OTHERS_POSTS
      });
    }

    if (license.IsLicensed === 'true' && config.PostEditTimeLimit !== '-1' && config.PostEditTimeLimit !== -1) {
      var timeLeft = post.create_at + config.PostEditTimeLimit * 1000 - Date.now();

      if (timeLeft <= 0) {
        canEdit = false;
      }
    }
  } else {
    // Backwards compatibility with pre-advanced permissions config settings.
    canEdit = isOwner && config.AllowEditPost !== 'never';

    if (config.AllowEditPost === _constants.General.ALLOW_EDIT_POST_TIME_LIMIT) {
      var _timeLeft = post.create_at + config.PostEditTimeLimit * 1000 - Date.now();

      if (_timeLeft <= 0) {
        canEdit = false;
      }
    }
  }

  return canEdit;
}

function getLastCreateAt(postsArray
/*: Array<Post>*/
)
/*: number*/
{
  var createAt = postsArray.map(function (p) {
    return p.create_at;
  });

  if (createAt.length) {
    return Reflect.apply(Math.max, null, createAt);
  }

  return 0;
}

var joinLeavePostTypes = [_constants.Posts.POST_TYPES.JOIN_LEAVE, _constants.Posts.POST_TYPES.JOIN_CHANNEL, _constants.Posts.POST_TYPES.LEAVE_CHANNEL, _constants.Posts.POST_TYPES.ADD_REMOVE, _constants.Posts.POST_TYPES.ADD_TO_CHANNEL, _constants.Posts.POST_TYPES.REMOVE_FROM_CHANNEL, _constants.Posts.POST_TYPES.JOIN_TEAM, _constants.Posts.POST_TYPES.LEAVE_TEAM, _constants.Posts.POST_TYPES.ADD_TO_TEAM, _constants.Posts.POST_TYPES.REMOVE_FROM_TEAM, _constants.Posts.POST_TYPES.COMBINED_USER_ACTIVITY]; // Returns true if a post should be hidden when the user has Show Join/Leave Messages disabled

function shouldFilterJoinLeavePost(post
/*: Post*/
, showJoinLeave
/*: boolean*/
, currentUsername
/*: string*/
)
/*: boolean*/
{
  if (showJoinLeave) {
    return false;
  } // Don't filter out non-join/leave messages


  if (joinLeavePostTypes.indexOf(post.type) === -1) {
    return false;
  } // Don't filter out join/leave messages about the current user


  return !isJoinLeavePostForUsername(post, currentUsername);
}

function isJoinLeavePostForUsername(post
/*: Post*/
, currentUsername
/*: string*/
)
/*: boolean*/
{
  if (!post.props || !currentUsername) {
    return false;
  }

  if (post.user_activity_posts) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = post.user_activity_posts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var childPost = _step.value;

        if (isJoinLeavePostForUsername(childPost, currentUsername)) {
          // If any of the contained posts are for this user, the client will
          // need to figure out how to render the post
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return post.props.username === currentUsername || post.props.addedUsername === currentUsername || post.props.removedUsername === currentUsername;
}

function isPostPendingOrFailed(post
/*: Post*/
)
/*: boolean*/
{
  return post.failed || post.id === post.pending_post_id;
}

function comparePosts(a
/*: Post*/
, b
/*: Post*/
)
/*: number*/
{
  var aIsPendingOrFailed = isPostPendingOrFailed(a);
  var bIsPendingOrFailed = isPostPendingOrFailed(b);

  if (aIsPendingOrFailed && !bIsPendingOrFailed) {
    return -1;
  } else if (!aIsPendingOrFailed && bIsPendingOrFailed) {
    return 1;
  }

  if (a.create_at > b.create_at) {
    return -1;
  } else if (a.create_at < b.create_at) {
    return 1;
  }

  return 0;
}

function isPostCommentMention(_ref)
/*: boolean*/
{
  var post = _ref.post,
      currentUser = _ref.currentUser,
      threadRepliedToByCurrentUser = _ref.threadRepliedToByCurrentUser,
      rootPost = _ref.rootPost;
  var commentsNotifyLevel = _constants.Preferences.COMMENTS_NEVER;
  var isCommentMention = false;
  var threadCreatedByCurrentUser = false;

  if (rootPost && rootPost.user_id === currentUser.id) {
    threadCreatedByCurrentUser = true;
  }

  if (currentUser.notify_props && currentUser.notify_props.comments) {
    commentsNotifyLevel = currentUser.notify_props.comments;
  }

  var notCurrentUser = post.user_id !== currentUser.id || post.props && post.props.from_webhook;

  if (notCurrentUser) {
    if (commentsNotifyLevel === _constants.Preferences.COMMENTS_ANY && (threadCreatedByCurrentUser || threadRepliedToByCurrentUser)) {
      isCommentMention = true;
    } else if (commentsNotifyLevel === _constants.Preferences.COMMENTS_ROOT && threadCreatedByCurrentUser) {
      isCommentMention = true;
    }
  }

  return isCommentMention;
}

function fromAutoResponder(post
/*: Post*/
)
/*: boolean*/
{
  return Boolean(post.type && post.type === _constants.Posts.SYSTEM_AUTO_RESPONDER);
}