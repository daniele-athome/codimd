"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllPosts = getAllPosts;
exports.getPost = getPost;
exports.getPostsInThread = getPostsInThread;
exports.getReactionsForPosts = getReactionsForPosts;
exports.makeGetReactionsForPost = makeGetReactionsForPost;
exports.getOpenGraphMetadata = getOpenGraphMetadata;
exports.getOpenGraphMetadataForUrl = getOpenGraphMetadataForUrl;
exports.getPostIdsInCurrentChannel = getPostIdsInCurrentChannel;
exports.makeGetPostIdsForThread = makeGetPostIdsForThread;
exports.makeGetPostIdsAroundPost = makeGetPostIdsAroundPost;
exports.makeGetPostsInChannel = makeGetPostsInChannel;
exports.makeGetPostsAroundPost = makeGetPostsAroundPost;
exports.makeGetPostsForThread = makeGetPostsForThread;
exports.makeGetCommentCountForPost = makeGetCommentCountForPost;
exports.getSearchMatches = getSearchMatches;
exports.makeGetMessageInHistoryItem = makeGetMessageInHistoryItem;
exports.makeGetPostsForIds = makeGetPostsForIds;
exports.getPostIdsInChannel = getPostIdsInChannel;
exports.getExpandedLink = getExpandedLink;
exports.makeIsPostCommentMention = exports.isPostIdSending = exports.getCurrentUsersLatestPost = exports.getLatestReplyablePostId = exports.getMostRecentPostIdInChannel = exports.getLastPostPerChannel = exports.getSearchResults = exports.getPostsInCurrentChannel = void 0;

require("core-js/modules/es7.object.get-own-property-descriptors");

require("core-js/modules/es6.object.keys");

require("core-js/modules/es6.string.link");

require("core-js/modules/es6.string.starts-with");

require("core-js/modules/es6.array.find");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es7.object.entries");

require("core-js/modules/es6.regexp.search");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

var _reselect = require("reselect");

var _common = require("./common");

var _preferences = require("./preferences");

var _helpers = require("../../utils/helpers");

var _constants = require("../../constants");

var _post_utils = require("../../utils/post_utils");

var _preference_utils = require("../../utils/preference_utils");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getAllPosts(state
/*: GlobalState*/
) {
  return state.entities.posts.posts;
}

function getPost(state
/*: GlobalState*/
, postId
/*: $ID<Post>*/
)
/*: Post*/
{
  return getAllPosts(state)[postId];
}

function getPostsInThread(state
/*: GlobalState*/
)
/*: RelationOneToMany<Post, Post>*/
{
  return state.entities.posts.postsInThread;
}

function getReactionsForPosts(state
/*: GlobalState*/
)
/*: RelationOneToOne<Post, {[string]: Reaction}>*/
{
  return state.entities.posts.reactions;
}

function makeGetReactionsForPost()
/*: (GlobalState, $ID<Post>) => ?{[string]: Reaction}*/
{
  return (0, _reselect.createSelector)(getReactionsForPosts, function (state
  /*: GlobalState*/
  , postId) {
    return postId;
  }, function (reactions, postId) {
    if (reactions[postId]) {
      return reactions[postId];
    }

    return null;
  });
}

function getOpenGraphMetadata(state
/*: GlobalState*/
)
/*: RelationOneToOne<Post, Object>*/
{
  return state.entities.posts.openGraph;
}

function getOpenGraphMetadataForUrl(state
/*: GlobalState*/
, url
/*: string*/
)
/*: Object*/
{
  return state.entities.posts.openGraph[url];
} // getPostIdsInCurrentChannel returns the IDs of posts loaded at the bottom of the channel. It does not include older
// posts such as those loaded by viewing a thread or a permalink.


function getPostIdsInCurrentChannel(state
/*: GlobalState*/
)
/*: ?Array<$ID<Post>>*/
{
  return getPostIdsInChannel(state, state.entities.channels.currentChannelId);
} // getPostsInCurrentChannel returns the posts loaded at the bottom of the channel. It does not include older posts
// such as those loaded by viewing a thread or a permalink.


var getPostsInCurrentChannel
/*: (GlobalState) => ?Array<PostWithFormatData>*/
= function () {
  var getPostsInChannel = makeGetPostsInChannel();
  return function (state
  /*: GlobalState*/
  ) {
    return getPostsInChannel(state, state.entities.channels.currentChannelId, -1);
  };
}();

exports.getPostsInCurrentChannel = getPostsInCurrentChannel;

function makeGetPostIdsForThread()
/*: (GlobalState, $ID<Post>) => Array<$ID<Post>>*/
{
  return (0, _helpers.createIdsSelector)(getAllPosts, function (state
  /*: GlobalState*/
  , rootId) {
    return state.entities.posts.postsInThread[rootId] || [];
  }, function (state
  /*: GlobalState*/
  , rootId) {
    return state.entities.posts.posts[rootId];
  }, function (posts, postsForThread, rootPost) {
    var thread = [];

    if (rootPost) {
      thread.push(rootPost);
    }

    postsForThread.forEach(function (id) {
      var post = posts[id];

      if (post) {
        thread.push(post);
      }
    });
    thread.sort(_post_utils.comparePosts);
    return thread.map(function (post) {
      return post.id;
    });
  });
}

function makeGetPostIdsAroundPost()
/*: (GlobalState, $ID<Post>, $ID<Channel>, {postsBeforeCount: number, postsAfterCount: number}) => ?Array<$ID<Post>>*/
{
  return (0, _helpers.createIdsSelector)(function (state
  /*: GlobalState*/
  , postId, channelId) {
    return state.entities.posts.postsInChannel[channelId];
  }, function (state
  /*: GlobalState*/
  , postId) {
    return postId;
  }, function (state
  /*: GlobalState*/
  , postId, channelId, options) {
    return options && options.postsBeforeCount;
  }, function (state
  /*: GlobalState*/
  , postId, channelId, options) {
    return options && options.postsAfterCount;
  }, function (postsForChannel, postId) {
    var postsBeforeCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants.Posts.POST_CHUNK_SIZE / 2;
    var postsAfterCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.Posts.POST_CHUNK_SIZE / 2;

    if (!postsForChannel) {
      return null;
    }

    var postIds
    /*: ?Array<$ID<Post>>*/
    = null;
    var postIndex = -1;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = postsForChannel[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var block = _step.value;
        var index = block.order.indexOf(postId);

        if (index === -1) {
          continue;
        }

        postIds = block.order;
        postIndex = index;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (postIndex === -1 || !postIds) {
      return null;
    } // Remember that posts that come after the post have a smaller index


    var minPostIndex = postsAfterCount === -1 ? 0 : Math.max(postIndex - postsAfterCount, 0);
    var maxPostIndex = postsBeforeCount === -1 ? postIds.length : Math.min(postIndex + postsBeforeCount + 1, postIds.length); // Needs the extra 1 to include the focused post

    return postIds.slice(minPostIndex, maxPostIndex);
  });
}

function formatPostInChannel(post
/*: Post*/
, previousPost
/*: ?Post*/
, index
/*: number*/
, allPosts
/*: IDMappedObjects<Post>*/
, postsInThread
/*: RelationOneToMany<Post, Post>*/
, postIds
/*: Array<$ID<Post>>*/
, currentUser
/*: UserProfile*/
, focusedPostId
/*: $ID<Post>*/
)
/*: PostWithFormatData*/
{
  var isFirstReply = false;
  var isLastReply = false;
  var highlight = false;
  var commentedOnPost;

  if (post.id === focusedPostId) {
    highlight = true;
  }

  if (post.root_id) {
    if (previousPost && previousPost.root_id !== post.root_id) {
      // Post is the first reply in a list of consecutive replies
      isFirstReply = true;

      if (previousPost && previousPost.id !== post.root_id) {
        commentedOnPost = allPosts[post.root_id];
      }
    }

    if (index - 1 < 0 || allPosts[postIds[index - 1]].root_id !== post.root_id) {
      // Post is the last reply in a list of consecutive replies
      isLastReply = true;
    }
  }

  var previousPostIsComment = false;

  if (previousPost && previousPost.root_id) {
    previousPostIsComment = true;
  }

  var postFromWebhook = Boolean(post.props && post.props.from_webhook);
  var prevPostFromWebhook = Boolean(previousPost && previousPost.props && previousPost.props.from_webhook);
  var consecutivePostByUser = false;

  if (previousPost && previousPost.user_id === post.user_id && post.create_at - previousPost.create_at <= _constants.Posts.POST_COLLAPSE_TIMEOUT && !postFromWebhook && !prevPostFromWebhook && !(0, _post_utils.isSystemMessage)(post) && !(0, _post_utils.isSystemMessage)(previousPost)) {
    // The last post and this post were made by the same user within some time
    consecutivePostByUser = true;
  }

  var threadRepliedToByCurrentUser = false;
  var replyCount = 0;
  var isCommentMention = false;

  if (currentUser) {
    var rootId = post.root_id || post.id;
    var threadIds = postsInThread[rootId] || [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = threadIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var pid = _step2.value;
        var p = allPosts[pid];

        if (!p) {
          continue;
        }

        if (p.user_id === currentUser.id) {
          threadRepliedToByCurrentUser = true;
        }

        if (!(0, _post_utils.isPostEphemeral)(p)) {
          replyCount += 1;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var rootPost = allPosts[rootId];
    isCommentMention = (0, _post_utils.isPostCommentMention)({
      post: post,
      currentUser: currentUser,
      threadRepliedToByCurrentUser: threadRepliedToByCurrentUser,
      rootPost: rootPost
    });
  }

  return _objectSpread({}, post, {
    isFirstReply: isFirstReply,
    isLastReply: isLastReply,
    previousPostIsComment: previousPostIsComment,
    commentedOnPost: commentedOnPost,
    consecutivePostByUser: consecutivePostByUser,
    replyCount: replyCount,
    isCommentMention: isCommentMention,
    highlight: highlight
  });
} // makeGetPostsInChannel creates a selector that returns up to the given number of posts loaded at the bottom of the
// given channel. It does not include older posts such as those loaded by viewing a thread or a permalink.


function makeGetPostsInChannel()
/*: (GlobalState, $ID<Channel>, number) => ?Array<PostWithFormatData>*/
{
  return (0, _reselect.createSelector)(getAllPosts, getPostsInThread, function (state
  /*: GlobalState*/
  , channelId
  /*: $ID<Channel>*/
  ) {
    return getPostIdsInChannel(state, channelId);
  }, _common.getCurrentUser, _preferences.getMyPreferences, function (state
  /*: GlobalState*/
  , channelId
  /*: $ID<Channel>*/
  , numPosts
  /*: number*/
  ) {
    return numPosts || _constants.Posts.POST_CHUNK_SIZE;
  }, function (allPosts, postsInThread, allPostIds, currentUser, myPreferences, numPosts) {
    if (!allPostIds) {
      return null;
    }

    var posts = [];
    var joinLeavePref = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_ADVANCED_SETTINGS, _constants.Preferences.ADVANCED_FILTER_JOIN_LEAVE)];
    var showJoinLeave = joinLeavePref ? joinLeavePref.value !== 'false' : true;
    var postIds = numPosts === -1 ? allPostIds : allPostIds.slice(0, numPosts);

    for (var i = 0; i < postIds.length; i++) {
      var post = allPosts[postIds[i]];

      if ((0, _post_utils.shouldFilterJoinLeavePost)(post, showJoinLeave, currentUser ? currentUser.username : '')) {
        continue;
      }

      var previousPost = allPosts[postIds[i + 1]] || null;
      posts.push(formatPostInChannel(post, previousPost, i, allPosts, postsInThread, postIds, currentUser, ''));
    }

    return posts;
  });
}

function makeGetPostsAroundPost()
/*: (GlobalState, $ID<Post>, $ID<Channel>) => ?Array<PostWithFormatData>*/
{
  var getPostIdsAroundPost = makeGetPostIdsAroundPost();
  var options = {
    postsBeforeCount: -1,
    // Where this is used in the web app, view state is used to determine how far back to display
    postsAfterCount: _constants.Posts.POST_CHUNK_SIZE / 2
  };
  return (0, _reselect.createSelector)(function (state
  /*: GlobalState*/
  , focusedPostId, channelId) {
    return getPostIdsAroundPost(state, focusedPostId, channelId, options);
  }, getAllPosts, getPostsInThread, function (state
  /*: GlobalState*/
  , focusedPostId) {
    return focusedPostId;
  }, _common.getCurrentUser, _preferences.getMyPreferences, function (postIds, allPosts, postsInThread, focusedPostId, currentUser, myPreferences) {
    if (!postIds || !currentUser) {
      return null;
    }

    var posts = [];
    var joinLeavePref = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_ADVANCED_SETTINGS, _constants.Preferences.ADVANCED_FILTER_JOIN_LEAVE)];
    var showJoinLeave = joinLeavePref ? joinLeavePref.value !== 'false' : true;

    for (var i = 0; i < postIds.length; i++) {
      var post = allPosts[postIds[i]];

      if ((0, _post_utils.shouldFilterJoinLeavePost)(post, showJoinLeave, currentUser.username)) {
        continue;
      }

      var previousPost = allPosts[postIds[i + 1]] || null;
      var formattedPost = formatPostInChannel(post, previousPost, i, allPosts, postsInThread, postIds, currentUser, focusedPostId);
      posts.push(formattedPost);
    }

    return posts;
  });
} // Returns a function that creates a creates a selector that will get the posts for a given thread.
// That selector will take a props object (containing a rootId field) as its
// only argument and will be memoized based on that argument.


function makeGetPostsForThread()
/*: (GlobalState, {rootId: $ID<Post>}) => Array<Post>*/
{
  return (0, _reselect.createSelector)(getAllPosts, function (state
  /*: GlobalState*/
  , _ref) {
    var rootId = _ref.rootId;
    return state.entities.posts.postsInThread[rootId] || [];
  }, function (state
  /*: GlobalState*/
  , _ref2) {
    var rootId = _ref2.rootId;
    return state.entities.posts.posts[rootId];
  }, function (posts, postsForThread, rootPost) {
    var thread = [];

    if (rootPost) {
      thread.push(rootPost);
    }

    postsForThread.forEach(function (id) {
      var post = posts[id];

      if (post) {
        thread.push(post);
      }
    });
    thread.sort(_post_utils.comparePosts);
    return thread;
  });
}

function makeGetCommentCountForPost()
/*: (GlobalState, {post: Post}) => number*/
{
  return (0, _reselect.createSelector)(getAllPosts, function (state, _ref3) {
    var post = _ref3.post;
    return state.entities.posts.postsInThread[post ? post.id : ''] || [];
  }, function (state, props) {
    return props;
  }, function (posts, postsForThread, _ref4) {
    var currentPost = _ref4.post;

    if (!currentPost) {
      return 0;
    }

    var count = 0;
    postsForThread.forEach(function (id) {
      var post = posts[id];

      if (post && post.state !== _constants.Posts.POST_DELETED && !(0, _post_utils.isPostEphemeral)(post)) {
        count += 1;
      }
    });
    return count;
  });
}

var getSearchResults
/*: (GlobalState) => Array<Post>*/
= (0, _reselect.createSelector)(getAllPosts, function (state
/*: GlobalState*/
) {
  return state.entities.search.results;
}, function (posts, postIds) {
  if (!postIds) {
    return [];
  }

  return postIds.map(function (id) {
    return posts[id];
  });
}); // Returns the matched text from the search results, if the server has provided them.
// These matches will only be present if the server is running Mattermost 5.1 or higher
// with Elasticsearch enabled to search posts. Otherwise, null will be returned.

exports.getSearchResults = getSearchResults;

function getSearchMatches(state
/*: GlobalState*/
)
/*: {[string]: Array<string>}*/
{
  return state.entities.search.matches;
}

function makeGetMessageInHistoryItem(type
/*: string*/
)
/*: (GlobalState) => string*/
{
  return (0, _reselect.createSelector)(function (state
  /*: GlobalState*/
  ) {
    return state.entities.posts.messagesHistory;
  }, function (messagesHistory) {
    var idx = messagesHistory.index[type];
    var messages = messagesHistory.messages;

    if (idx >= 0 && messages && messages.length > idx) {
      return messages[idx];
    }

    return '';
  });
}

function makeGetPostsForIds()
/*: (GlobalState, Array<$ID<Post>>) => Array<Post>*/
{
  return (0, _helpers.createIdsSelector)(getAllPosts, function (state
  /*: GlobalState*/
  , postIds) {
    return postIds;
  }, function (allPosts, postIds) {
    if (!postIds) {
      return [];
    }

    return postIds.map(function (id) {
      return allPosts[id];
    });
  });
}

var getLastPostPerChannel
/*: (GlobalState) => RelationOneToOne<Channel, Post>*/
= (0, _reselect.createSelector)(getAllPosts, function (state
/*: GlobalState*/
) {
  return state.entities.posts.postsInChannel;
}, function (allPosts, postsInChannel) {
  var ret = {};

  for (var _i = 0, _Object$entries = Object.entries(postsInChannel); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        channelId = _Object$entries$_i[0],
        postsForChannel = _Object$entries$_i[1];

    var recentBlock = (postsForChannel
    /*: any*/
    ).find(function (block) {
      return block.recent;
    });

    if (!recentBlock) {
      continue;
    }

    var postId = recentBlock.order[0];

    if (allPosts.hasOwnProperty(postId)) {
      ret[channelId] = allPosts[postId];
    }
  }

  return ret;
});
exports.getLastPostPerChannel = getLastPostPerChannel;
var getMostRecentPostIdInChannel
/*: (GlobalState, $ID<Channel>) => ?$ID<Post>*/
= (0, _reselect.createSelector)(getAllPosts, function (state
/*: GlobalState*/
, channelId) {
  return getPostIdsInChannel(state, channelId);
}, _preferences.getMyPreferences, function (posts, postIdsInChannel, preferences) {
  if (!postIdsInChannel) {
    return '';
  }

  var key = (0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_ADVANCED_SETTINGS, _constants.Preferences.ADVANCED_FILTER_JOIN_LEAVE);
  var allowSystemMessages = preferences[key] ? preferences[key].value === 'true' : true;

  if (!allowSystemMessages) {
    // return the most recent non-system message in the channel
    var postId;

    for (var i = 0; i < postIdsInChannel.length; i++) {
      var p = posts[postIdsInChannel[i]];

      if (!p.type || !p.type.startsWith(_constants.Posts.SYSTEM_MESSAGE_PREFIX)) {
        postId = p.id;
        break;
      }
    }

    return postId;
  } // return the most recent message in the channel


  return postIdsInChannel[0];
});
exports.getMostRecentPostIdInChannel = getMostRecentPostIdInChannel;
var getLatestReplyablePostId
/*: (GlobalState) => $ID<Post>*/
= (0, _reselect.createSelector)(getPostsInCurrentChannel, function (posts) {
  if (!posts) {
    return '';
  }

  var latestReplyablePost = posts.find(function (post) {
    return post.state !== _constants.Posts.POST_DELETED && !(0, _post_utils.isSystemMessage)(post) && !(0, _post_utils.isPostEphemeral)(post);
  });

  if (!latestReplyablePost) {
    return '';
  }

  return latestReplyablePost.id;
});
exports.getLatestReplyablePostId = getLatestReplyablePostId;
var getCurrentUsersLatestPost
/*: (GlobalState, $ID<Post>) => ?PostWithFormatData*/
= (0, _reselect.createSelector)(getPostsInCurrentChannel, _common.getCurrentUser, function (_, rootId) {
  return rootId;
}, function (posts, currentUser, rootId) {
  if (!posts) {
    return null;
  }

  var lastPost = posts.find(function (post) {
    // don't edit webhook posts, deleted posts, or system messages
    if (post.user_id !== currentUser.id || post.props && post.props.from_webhook || post.state === _constants.Posts.POST_DELETED || (0, _post_utils.isSystemMessage)(post) || (0, _post_utils.isPostEphemeral)(post) || (0, _post_utils.isPostPendingOrFailed)(post)) {
      return false;
    }

    if (rootId) {
      return post.root_id === rootId || post.id === rootId;
    }

    return true;
  });
  return lastPost;
}); // getPostIdsInChannel returns the IDs of posts loaded at the bottom of the given channel. It does not include older
// posts such as those loaded by viewing a thread or a permalink.

exports.getCurrentUsersLatestPost = getCurrentUsersLatestPost;

function getPostIdsInChannel(state
/*: GlobalState*/
, channelId
/*: $ID<Channel>*/
)
/*: ?Array<$ID<Post>>*/
{
  var postsForChannel = state.entities.posts.postsInChannel[channelId];

  if (!postsForChannel) {
    return null;
  }

  var recentBlock = postsForChannel.find(function (block) {
    return block.recent;
  });

  if (!recentBlock) {
    return null;
  }

  return recentBlock.order;
}

var isPostIdSending = function isPostIdSending(state
/*: GlobalState*/
, postId
/*: $ID<Post>*/
) {
  return (
    /*: boolean*/
    state.entities.posts.pendingPostIds.some(function (sendingPostId) {
      return sendingPostId === postId;
    })
  );
};

exports.isPostIdSending = isPostIdSending;

var makeIsPostCommentMention = function makeIsPostCommentMention()
/*: ((GlobalState, $ID<Post>) => boolean)*/
{
  return (0, _reselect.createSelector)(getAllPosts, getPostsInThread, _common.getCurrentUser, getPost, function (allPosts, postsInThread, currentUser, post) {
    if (!post) {
      return false;
    }

    var threadRepliedToByCurrentUser = false;
    var isCommentMention = false;

    if (currentUser) {
      var rootId = post.root_id || post.id;
      var threadIds = postsInThread[rootId] || [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = threadIds[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var pid = _step3.value;
          var p = allPosts[pid];

          if (!p) {
            continue;
          }

          if (p.user_id === currentUser.id) {
            threadRepliedToByCurrentUser = true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var rootPost = allPosts[rootId];
      isCommentMention = (0, _post_utils.isPostCommentMention)({
        post: post,
        currentUser: currentUser,
        threadRepliedToByCurrentUser: threadRepliedToByCurrentUser,
        rootPost: rootPost
      });
    }

    return isCommentMention;
  });
};

exports.makeIsPostCommentMention = makeIsPostCommentMention;

function getExpandedLink(state
/*: GlobalState*/
, link
/*: string*/
)
/*: string*/
{
  return state.entities.posts.expandedURLs[link];
}